# Collections

A collection is a powerfull built in field type which craetes an array / list of grouped fields. If you for example 
want to collect a list of participants for a dinner, you could set that up like this in the config:

```
{
    id: "participants",
    type: "collection",
    isRequired: true,
    init: true,
    fields: [
        {
            id: "name",
            label: "Name",
            type: "text",
            isRequired: true
        },
        {
            id: "vegan",
            label: "Is vegan?",
            type: "checkbox"
        }
    ]
}
```

And than render it like this:

```
render={({ fieldProps, errors }) => {
    return (
        <>
            <div>

                {fieldProps.fields.participants ? fieldProps.fields.participants.map((subFields, index) => (
                    <div key={`participants-${index}`}>

                        {subFields.name}
                        <br />

                        {subFields.vegan}
                        <br />

                        <button
                            type="button"
                            onClick={() => fieldProps.onCollectionAction("participants", "remove", index)}
                        >
                            Remove entry
                        </button>

                    </div>)
                ) : null}

                <button
                    type="button"
                    onClick={() => fieldProps.onCollectionAction("participants", "add")}
                >
                    Add entry
                </button>

            </div>

            {errors && errors.participants ? (
                <div style={{ color: "red" }}>
                    Please add at least one entry!
                </div>
            ) : null}
        </>
    );
}}
```

Collection have following options:

- **id**: This will be the key for the array in the data structure
- **isRequired**: If this is set, than at least one entry has to be added
- **init**: If this is true, one initial empty entry will be set
- **min**: Add a number for the minimum amount of entries
- **max**: Add a number for the maximum amount of entries
- **uniqEntries**: If true, all entries have to be uniq
- **setInitialData**: A callback which adds initial data to a newly created collection entry, with following params:
    - **data**: The collections data
    - **alldata**: All the data in the form
    - **type**: In case of a union type collection, the type of the new entry

## Computed Collections

Sometimes you want to compute values based on the data of the individual collection entries, you can do this with 
the `itemData` on the `computedValue` function:

```
{
    id: "factorials",
    type: "collection",
    init: true,
    fields: [
        {
            id: "factor1",
            label: "Factor 1",
            type: "number"
        },
        {
            id: "factor2",
            label: "Factor 2",
            type: "number"
        },
        {
            id: "result",
            label: "Result of Factor 1 x Factor 2",
            type: "number",
            isDisabled: true,
            computedValue: (data, itemData) => {
                let result = 0;
                if (itemData.factor1 && itemData.factor2) {
                    result = Number(itemData.factor1) * Number(itemData.factor2);
                }
                return result !== 0 ? result : "";
            }
        }
    ]
}
```

##Â Union Type Collections

Like in GraphQL, a collection can have multiple different field configs, so called types. You define them like this:

```
{
    id: "meals",
    type: "collection",
    isRequired: true,
    init: "food",
    fields: {
        food: [
            {
                id: "name",
                label: "Food Name",
                type: "text",
                isRequired: true
            },
            {
                id: "calories",
                label: "Calories",
                type: "text"
            }
        ],
        drink: [
            {
                id: "name",
                label: "Drink Name",
                type: "text",
                isRequired: true
            },
            {
                id: "alcohol",
                label: "Alcohol Percentage",
                type: "text"
            },
            {
                id: "fullName",
                label: "Full Name",
                type: "text",
                isDisabled: true,
                computedValue: (data, itemData) => {
                    return `${itemData.name} ${itemData.alcohol}%`;
                }
            }
        ]
    }
}
```

The difference is that you need to put the field config array into an object with the keys for each type.

One thing to than change is in the Form render funtion, you need to explicitely define which type to add, something like this:

```
<button
    type="button"
    onClick={() => fieldProps.onCollectionAction("collection9", "add", "food")}
>
    + Food
</button>
```

## Collection actions

In the examples above, we used `onCollectionAction()` a lot. The function params are:

- **path:** The unique path of the collection you want to manipulate
- **action:** What you want to do. Currently you can use `add`, `remove` and `move`
- **index:** The index of the collection entry
- **index2:** A second index. Currently only needed for `move` actions where it will be the destination (check the drag and drop example in the demos for an advanced example)

[Related Demo](https://stages-demo.vercel.app/collections)